\chapter{Conclusion}
\label{chap:conclusion}

This report has described the process of creating a Pokemon battle simulator and teaching AI agents how to play Pokemon.
The project set out figure out if humans could improve their play by analyzing the strategies that the AI agents come up
with. Through multiple training sessions, the agents have learned a lot, however more training is required in order to 
make a formal conclusion about whether it will surpass a human player. The results show steady improvements over time, but
there is a long way to go before the agent will win any tournaments.

The project wanted to provide a quick way to calculate the odds of a player winning given two sets of Pokemon. This has
partially been solved, but a clear interface is missing in order to ship it as a final product.

\section{The good and the bad parts}
\label{sec:good-bad-parts}

\subsection{Good parts}
The simulator works both with custom and external environments, providing great flexibility depending
on what kind of training is desired. The custom environment, while not fully feature complete, is open to extension and
can support multiple game environments, such as different generations of game rules. The external environment, Poke-env, 
supports most features found in the Pokemon games and comes with a visual replay option for presenting discovered strategies.

\subsection{Bad parts}
The custom environment is not feature complete. The simulator will only provide good results if its environment reflects
reality. While the missing features were declared in the initial requirements as optional for the purposes finishing the
project within the allotted time, they are crucial to provide accurate results to be used in a real product.

The training process is slower than anticipated. During training, we measured an average of 20 episodes per second. This 
is due to both environments being heavily CPU bound with limited processing able to be sent to the GPU. The training time
can most likely be improved in the custom environment by vectorizing the observations provided and by implementing 
multi-threading to divy up the work performed by the CPU to multiple threads. 
